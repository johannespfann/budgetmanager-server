# Login

* Ein Job, der nach einiger Zeit die alten ActivationTickets wieder löscht
* User ist nicht aktiviert in der Datenbank


1) TODO 
- create date und last logedin für User 
- Vorgehen bei Rest-Schnittstellen -> Interface für API, Facaden, Injection für    Abhängigkeiten usw. prototypisch implementieren 
- user rescoure -> login resource  
- restschnittstellen überdenken/ändern POST, PUT, PATCH, GET, DELETE 

######## login
2) registrieren 
- bekommt user mit email, username und pw 
- user wird gespeichert 
- token wird angelegt  
- email wird wird token versendet 
- im activationpool Eintrag angelegt

 * email, password pw ist nicht gesetzt 
 * email gibt es bereits 
 * email versenden scheitert

3) user activieren 
- token wird gesendet 
- user für token wird gesucht und abgehackt 
- die email für den Token wird gesetzt. (andere einfach ignoriert) 
- user wird aktiviert
 
 * user email ist nicht gsetzt 
 * user wurde niemals registriert 
 * token gibt es nicht

4) unregister user 
- token wird generiert 
- email mit token wird versendet

5) unregister confirme 
- token, user wird mitgeliefert 
- user wird gelöscht

6) resend email for activation 
- email username und password müssen nochmal versendet werden 
- token wird neu registriert mit der "email" die aktuell angekommen ist

####### category

7) get all categories
- erhalte user von header
- suche alle kategorien von user

* securityprüfung war nicht erfolgreich 
* löschen geht schief

8) lösche kategorie
- suche kategorie mit hash
- prüfe ob user auch kategorie löschen darf
- suche ersatzkategorie mit hash
- prüfe ob user diese kategorie besitzt
- lösche kategorie

* kategorie hash und ersatzkategorie existieren
* beide gehören dem user
* zu löschende kategorie ist nicht default
* löschen geht schief

9) add categorey
- erzeuge user von header
- baue kategorieobject zusammen
- speichere kategorie

* alle werte sind vorhanden
* user wurde gefunden
* speichern war nicht erfolgreich


/**
 * dateobjects
 */

private LocalDate today;

private Date startDate;

private Date lastExecutedThisMonth;

private Date lastExecuted;


@Before
public void setUp(){
    today = LocalDate.of(2018, Month.MARCH,27);
    startDate = convert(LocalDate.of(2018,Month.JANUARY,1));
    lastExecuted = convert(LocalDate.of(2018,Month.FEBRUARY,16));
}

@Test
public void testTodayIsBeforStartTime(){
    // prepare
    RotationEntry entry = new RotationEntry();
    entry.setStart_at(startDate);
    LocalDate now = LocalDate.of(2017,Month.APRIL,3);

    // execute
    boolean executable = new Main().isExecutable(now,entry);

    // validate
    Assert.assertFalse(executable);
}


@Test
public void testLastExecutedThisMonth(){
    // prepare
    RotationEntry entry = new RotationEntry();
    entry.setStart_at(startDate);
    entry.setLast_executed(lastExecuted);

    LocalDate now = LocalDate.of(2018,Month.FEBRUARY,18);
    // execute
    boolean executable = new Main().isExecutable(now ,entry);

    // validate
    Assert.assertFalse(executable);
}

@Test
public void testLastExecutedLastMonthSameDay(){
    // prepare
    RotationEntry entry = new RotationEntry();
    entry.setStart_at(startDate);
    entry.setLast_executed(lastExecuted);

    LocalDate now = LocalDate.of(2018,Month.FEBRUARY,16);
    // execute
    boolean executable = new Main().isExecutable(now ,entry);

    // validate
    Assert.assertFalse(executable);

}

@Test
public void testLastExecutedLastMonthAfterToday(){
    RotationEntry entry = new RotationEntry();
    entry.setStart_at(startDate);
    entry.setLast_executed(lastExecuted);

    LocalDate now = LocalDate.of(2018,Month.MARCH,20);

    // execute
    boolean executable = new Main().isExecutable(now ,entry);

    // validate
    Assert.assertFalse(executable);
}

@Test
public void testLastExecutedLastMonthSameToday(){
    RotationEntry entry = new RotationEntry();
    entry.setStart_at(startDate);
    entry.setLast_executed(lastExecuted);

    LocalDate now = LocalDate.of(2018,Month.MARCH,16);

    // execute
    boolean executable = new Main().isExecutable(now ,entry);

    // validate
    Assert.assertTrue(executable);
}



public Date convert(LocalDate aLocalDate){
    return Date.from(aLocalDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
}

